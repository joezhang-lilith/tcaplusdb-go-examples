
#@ block: file_head
% import datetime
% create_time = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
# encoding: {{encoding}}
# auto generated by tdr2py, don't edit!
# create time: {{create_time}}

#@ endblock

#@ block: common_code
% filename = get('filename')
% if filename == '__init__.py':
import datetime
import struct
import socket

class TdrException(Exception):
    def __init__(self, msg, struct_name = None, entry_name = None):
        self.__msg = "[%s.%s]%s" % (struct_name and struct_name or '-',
                                    entry_name and entry_name or '-',
                                    msg)
    def __str__(self):
        return 'TdrException:%s' % self.__msg

    __repr__ = __str__


# for unpack_from_dict
tdr_str2time = lambda v:datetime.time(*[int(m) for m in v.split(':')]) if v else None
tdr_str2date = lambda v:datetime.date(*[int(m) for m in v.split('-')]) if v else None

def tdr_str2datetime(v):
    if not v:
        return
    dpart, tpart = v.split(' ')
    return datetime.datetime(*[int(m) for m in dpart.split('-')] + [
        int(m) for m in tpart.split(':')])

def tdr_int2date(v):
    d = (v & 0xFF000000) >> 24
    m = (v & 0x00FF0000) >> 16
    y = (v & 0x0000FFFF)
    try:
        return datetime.date(y, m, d)
    except:
        pass

def tdr_int2time(v):
    s = (v & 0xFF000000) >> 24
    m = (v & 0x00FF0000) >> 16
    h = (v & 0x0000FFFF)
    try:
        return datetime.time(h, m, s)
    except:
        pass

def tdr_int2datetime(v):
    tt = (v & 0xFFFFFFFF00000000L) >> 32
    dd = (v & 0x00000000FFFFFFFFL)

    d = (dd & 0xFF000000) >> 24
    m = (dd & 0x00FF0000) >> 16
    y = (dd & 0x0000FFFF)

    s = (tt & 0xFF000000) >> 24
    M = (tt & 0x00FF0000) >> 16
    h = (tt & 0x0000FFFF)
    try:
        return datetime.datetime(y, m, d, h, M, s)
    except:
        pass

def tdr_date2int(v):
    if not v:
        return 0
    d = v.day << 24| v.month << 16 | v.year
    return d

def tdr_time2int(v):
    if not v:
        return 0
    t = v.second << 24 | v.minute << 16 | v.hour
    return t

def tdr_datetime2int(v):
    if not v:
        return 0
    d = v.day << 24 | v.month << 16 | v.year
    t = v.second << 24 | v.minute << 16 | v.hour
    return (t << 32 | d)

def tdr_pack_string(buf, offset, v, size):
    if isinstance(v, unicode):
        v = v.encode('{{CHARSET}}')
    size = min(len(v), size - 1)
    struct.pack_into('!I%dsb' % len(v), buf, offset, size + 1, v, 0)
    return size + 5

def tdr_unpack_string(buf, offset, struct_name=None, entry_name=None):
    n, = struct.unpack_from('!I', buf, offset)
    val, el = struct.unpack_from('%dsb' % (n - 1), buf, offset + 4)
    if el != 0:
        raise TdrException('string not end with null:offset=%d' % (
            offset, struct_name, entry_name))
    return val, n + 4


def tdr_to_json(typeid, v):
    % json_types = PY_PACKINFO_PRIMARY_TYPE.keys() + [TYPE_STRING]
    if typeid in ({{TYPE_STRUCT}}, {{TYPE_UNION}}):
        return v.pack_into_dict()
    if typeid in {{json_types}}:
        return v
    if typeid == {{TYPE_DATE}}:
        return v.strftime('%Y-%m-%d') if v else ''
    if typeid == {{TYPE_TIME}}:
        return v.strftime('%H:%M:%S') if v else ''
    if typeid == {{TYPE_DATETIME}}:
        return v.strftime('%Y-%m-%d %H:%M:%S') if v else ''
    if typeid == {{TYPE_IP}}:
        return socket.inet_ntoa(v)

    raise TdrException('unsupport type:typeid=%s' % typeid)


def tdr_from_json(typeid, v, klass = None):
    if typeid == {{TYPE_STRUCT}}:
        return klass().unpack_from_dict(v)
    if typeid in ({{TYPE_INT8}},{{TYPE_UINT8}}, {{TYPE_INT16}}, {{TYPE_UINT16}},
                  {{TYPE_INT32}}, {{TYPE_UINT32}}, {{TYPE_INT64}}, {{TYPE_UINT64}}):
        return int(v)
    if typeid in ({{TYPE_FLOAT}}, {{TYPE_DOUBLE}}):
        return float(v)
    if typeid == {{TYPE_STRING}}:
        return v
    if typeid == {{TYPE_CHAR}}:
        return v[:1]
    if typeid == {{TYPE_TIME}}:
        return tdr_str2time(v)
    if typeid == {{TYPE_DATE}}:
        return tdr_str2date(v)
    if typeid == {{TYPE_DATETIME}}:
        return tdr_str2datetime(v)
    if typeid == {{TYPE_IP}}:
        return socket.inet_aton(v)

    raise TdrException('unsupport typeid:%s' % typeid)


    % fix_packer_fmt = set(PY_PACKINFO_PRIMARY_TYPE.values() + \
                           [v[0] for v in PY_PACKINFO_IP.values()] + \
                           [v[0] for v in PY_PACKINFO_DATETIME.values()])
    % fix_packer_fmt = list(fix_packer_fmt)
    % fix_packer_fmt.sort()
    % for fmt in fix_packer_fmt:
        % if fmt not in ('b', 'c', '4s'):
tdr_packer_{{fmt}} = struct.Struct('!{{fmt}}')
        % else:
tdr_packer_{{fmt}} = struct.Struct('{{fmt}}')
        % end
    % end

% else:
import struct
import cStringIO
from __init__ import *
% end
#@ endblock

#@ block: py_value_int
{{c_default(value, 0)}}\\
#@ endblock

#@ block: py_value_float
{{c_default(value, 0.0)}}\\
#@ endblock

#@ block: py_value_string
"{{c_default(c_escapestr(value), '')}}"\\
#@ endblock

#@ block: py_value_char
% if len(value) > 1:
    % raise Exception('wrong char value')
% else:
'{{c_default(c_escapestr(value), "\\0")}}'\\
% end
#@ endblock

#@ block: py_value_date
tdr_str2date("{{c_default(value, '1970-01-01')}}")\\
#@ endblock

#@ block: py_value_time
tdr_str2time("{{c_default(value, '00:00:00')}}")\\
#@ endblock

#@ block: py_value_datetime
tdr_str2datetime("{{c_default(value, '1970-01-01 00:00:00')}}")\\
#@ endblock

#@ block: py_value_ip
% if value:
socket.inet_aton('{{value}}')\\
% else:
socket.inet_aton('0.0.0.0')\\
% end
#@ endblock

#@ block: class_head
class {{name}}(object):
    MAXSIZE = {{maxsize}}
    BASEVERSION = {{base_version}}
    CURRVERSION = {{version}}

% for fld in filter(lambda f:f.version > base_version, fields):
    VERSION_{{fld.name}} = {{fld.version}}
% end
% if c_gen_spec:
    TDR_SPEC = [
        # (fld_name, fld_type, fld_array_count)
    % for fld in fields:
        % fld_count = fld.count if fld.count else 'None'
        ('{{fld.name}}', '{{fld.type}}', {{fld_count}}),
    %end
    ]
% end
#@ endblock


#@ block:struct_init
def __init__(self):
% for fld in fields:
{{!c_render_block('init_field', 4, fld)}}
% end
#@ endblock

#@ block: init_field
% if count:
    % if refer:
        % refer_fld = structdef.get_field(refer)
        % if refer_fld.defaultvalue and c_get_constv(refer_fld.defaultvalue) > 0:
self.{{name}} = [{{c_render_block('py_value_expr', 0, _context_)}} for _ in range(self.{{refer}})]\\
        % else:
self.{{name}} = []\\
        % end
    % else:
self.{{name}} = [{{c_render_block('py_value_expr', 0, _context_)}} for _ in range({{count}})]\\
    % end
% elif typedef.typeid == TYPE_UNION:
self._{{name}} = None
% else:
self.{{name}} = {{c_render_block('py_value_expr', 0, _context_)}}
  % for f, v in fvals.iteritems():
self.{{name}}.{{f}} = {{v}}
  % end
% end
#@ endblock

#@ block: py_value_expr
% tdr_value_exprs = {TYPE_INT8:'py_value_int',\
                     TYPE_UINT8:'py_value_int',\
                     TYPE_INT16:'py_value_int',\
                     TYPE_UINT16:'py_value_int',\
                     TYPE_INT32:'py_value_int',\
                     TYPE_UINT32:'py_value_int',\
                     TYPE_INT64:'py_value_int',\
                     TYPE_UINT64:'py_value_int',\
                     TYPE_FLOAT:'py_value_float',\
                     TYPE_DOUBLE:'py_value_float',\
                     TYPE_CHAR:'py_value_char',\
                     TYPE_STRING:'py_value_string',\
                     TYPE_DATE:'py_value_date',\
                     TYPE_TIME:'py_value_time',\
                     TYPE_DATETIME:'py_value_datetime',\
                     TYPE_IP:'py_value_ip',}
% if typedef.typeid in tdr_value_exprs:
{{!c_render_block(tdr_value_exprs[typedef.typeid], value=defaultvalue)}}\\
% elif typedef.typeid == TYPE_STRUCT:
{{type}}()\\
% elif typedef.typeid == TYPE_UNION:
{{type}}(self.{{select}})\\
% else:
   % assert False
% end
#@ endblock

#@ block: union_wrapper
% for fld in filter(lambda f:f.typedef.typeid==TYPE_UNION and not f.count, fields):
    % fname = fld.name
@property
def {{fname}}(self):
    if self._{{fname}} is None:
        self._{{fname}} = {{fld.typedef.name}}(self.{{fld.select}})
    return self._{{fname}}
% end
#@ endblock

#@ block: class_str
def __str__(self):
    out = cStringIO.StringIO()
    self.tostr(out)
    return out.getvalue()

__repr__ = __str__
#@ endblock

#@ block: struct_tostr
def tostr(self, out, indent = 0):
    spc1, spc2 = ' ' * indent, ' ' * (indent + 2)
    out.write('{{name}}=[\n')
% for fld in fields:
    out.write(spc2)
    out.write('{{fld.name}}:')
    % if fld.count:
    out.write('[\n')
    for item in self.{{fld.name}}:
        out.write(spc2)
{{!c_render_block('tostr_field', 8, fld=fld, vval='item')}}
    out.write(spc2 + ']\n')
    % else:
{{!c_render_block('tostr_field', 4, fld=fld, vval='self.' + fld.name)}}
    % end
%end
    out.write('%s]\n' % spc1)
#@ endblock

#@ block: tostr_field (fld, vval)
% if fld.typeid in (TYPE_STRUCT, TYPE_UNION):
{{vval}}.tostr(out, indent + 2)
% elif fld.typeid == TYPE_STRING:
if isinstance({{vval}}, unicode):
    out.write('%s\n' % {{vval}}.encode('{{CHARSET}}'))
else:
    out.write('%s\n' % {{vval}})
% elif fld.typeid == TYPE_IP:
out.write('%s\n' % socket.inet_ntoa({{vval}}))
% else:
out.write('%s\n' % {{vval}})
% end
#@ endblock

#@ block: struct_pack (*StructDef)
def pack(self, cutver = 0, maxsize = 0):
    if maxsize == 0:
        maxsize = {{maxsize}}

    buf = bytearray(maxsize)
    n = self.pack_into(buf, 0, cutver)
    return buf[:n]

def pack_into(self, buf, offset = 0, cutver = 0):
    if cutver == 0:
        cutver = self.CURRVERSION
% if versionindicator:
    self.{{versionindicator}} = cutver
% end
{{c_render_block('struct_pack_check_array', 4, _context_)}}
    offset0 = offset
% last_ver = 0
% for gtype, ver, flds in c_grouping_pack_flds(fields):
    % if last_ver != ver:
        % last_ver = ver
    if cutver >= {{ver}}:
    % end
    % if gtype == PY_PACK_GROUP_MERGE:
{{c_render_block('struct_pack_merge', 8, flds=flds, klass=name)}}
    % else:
        % fld = flds[0]
        % if fld.sizeinfo:
        _off = offset
        % end
        % if fld.count:
{{c_render_block('struct_pack_array', 8, fld)}}
        % elif fld.typeid == TYPE_STRING:
{{c_render_block('struct_pack_string', 8, fld)}}
        % elif fld.typeid in (TYPE_STRUCT, TYPE_UNION):
{{c_render_block('struct_pack_struct', 8, fld)}}
        % else:
            % assert False
        % end
        % if fld.sizeinfo:
        self.{{fld.sizeinfo}} = offset - _off
{{c_render_block('struct_pack_sizeinfo', 8, fld)}}
        % end
    % end
% end
    return offset - offset0
#@ endblock

#@ block: struct_pack_check_array (*StructDef)
% for fld in filter(lambda f: f.count, fields):
    % if fld.refer:
if len(self.{{fld.name}}) > {{fld.count}}:
    raise TdrException('too-large-array:%d,expect<=%d' % (len(self.{{fld.name}}), {{fld.count}}),
                       '{{fld.structdef.name}}', '{{fld.name}}')
    % else:
if len(self.{{fld.name}}) != {{fld.count}}:
    raise TdrException('wrong-array:%d,expect=%d' % (len(self.{{fld.name}}), {{fld.count}}),
                       '{{fld.structdef.name}}', '{{fld.name}}')
    % end
    % if fld.refer:
self.{{fld.refer}} = len(self.{{fld.name}})
    % end
% end
#@ endblock

#@ block: struct_pack_merge (flds, klass)
% fmt, size, fld_list = c_py_get_merge_pack_info(flds)
{{klass}}._packer_{{fmt}}.pack_into(buf, offset, {{fld_list}})
offset += {{size}}
% for fld in filter(lambda f:f.sizeinfo, flds):
    % if fld.typeid in FIXSIZE_TYPES:
self.{{fld.sizeinfo}} = {{FIXSIZE_TYPES[fld.typeid]}}
{{c_render_block('struct_pack_sizeinfo', 0, fld)}}
    % else:
        % assert False
    % end
% end
#@ endblock

#@ block: struct_pack_struct
offset += self.{{name}}.pack_into(buf, offset, cutver)
#@ endblock

#@ block: struct_pack_string (*EntryDef)
offset += tdr_pack_string(buf, offset, self.{{name}}, {{size}})
#@ endblock

#@ block: struct_pack_array (*EntryDef)
% typeid = typedef.typeid
% if typeid in PY_PACKINFO_PRIMARY_TYPE:
    % fmt = PY_PACKINFO_PRIMARY_TYPE[typeid]
    % name = 'self.' + name
    % size = FIXSIZE_TYPES[typeid]
struct.pack_into('!%d{{fmt}}' % len({{name}}), buf, offset, *{{name}})
offset += len({{name}}) * {{size}}
% elif typeid in PY_PACKINFO_DATETIME:
    % fmt, _, expr = PY_PACKINFO_DATETIME[typeid]
    % size = FIXSIZE_TYPES[typeid]
    % name = 'self.' + name
struct.pack_into('!%d{{fmt}}' % len({{name}}), buf, offset, *{{c_render_code(expr, var=name)}})
offset += len({{name}}) * {{size}}
% elif typeid == TYPE_STRING:
{{c_render_block('struct_pack_array_string', 0, _context_)}}
% elif typeid == TYPE_IP:
{{c_render_block('struct_pack_array_ip', 0, _context_)}}
% elif typeid in (TYPE_STRUCT, TYPE_UNION):
{{c_render_block('struct_pack_array_struct', 0, _context_)}}
% else:
    % assert False
% end
#@ endblock

#@ block: struct_pack_array_string (*EntryDef)
for item in self.{{name}}:
    offset += tdr_pack_string(buf, offset, item, {{size}})
#@ endblock

#@ block: struct_pack_array_ip (*EntryDef)
% fmt, vexpr = PY_PACKINFO_IP[typeid]
% size = FIXSIZE_TYPES[typeid]
for item in self.{{name}}:
    tdr_packer_{{fmt}}.pack_into(buf, offset, {{c_render_code(vexpr, 0, var='item')}})
    offset += {{size}}
#@ endblock

#@ block: struct_pack_array_struct
for item in self.{{name}}:
    offset += item.pack_into(buf, offset, cutver)
#@ endblock

#@ block: struct_pack_sizeinfo (*FieldDef)
% szfld = structdef.get_field(sizeinfo)
% assert szfld.typeid in PY_PACKINFO_PRIMARY_TYPE
% fmt = PY_PACKINFO_PRIMARY_TYPE[szfld.typeid]
% fld_offset = structdef.get_field_offset(sizeinfo)
tdr_packer_{{fmt}}.pack_into(buf, offset0+{{fld_offset}}, self.{{sizeinfo}})
#@ endblock

#@ block: struct_unpack
def unpack(self, buf, offset = 0, cutver = 0):
    if cutver == 0:
        cutver = self.CURRVERSION

    offset0 = offset
% last_ver = 0
% if versionindicator:
    % fld_offset = get_field_offset(versionindicator)
    % verfld = get_field(versionindicator)
    % fmt = PY_PACKINFO_PRIMARY_TYPE[verfld.typeid]
    cutver = min(cutver, tdr_packer_{{fmt}}.unpack_from(buf, offset+{{fld_offset}})[0])
% end
% for gtype, ver, flds in c_grouping_pack_flds(fields):
    % if last_ver != ver:
        % last_ver = ver
    if cutver >= {{ver}}:
    % end
    % if gtype == PY_PACK_GROUP_MERGE:
{{c_render_block('struct_unpack_merge', 8, flds=flds, klass=name)}}
    % else:
        % fld = flds[0]
        % if fld.count:
{{c_render_block('struct_unpack_array', 8, fld)}}
        % elif fld.typeid == TYPE_STRING:
{{c_render_block('struct_unpack_string', 8, fld)}}
        % elif fld.typeid in (TYPE_STRUCT, TYPE_UNION):
{{c_render_block('struct_unpack_struct', 8, fld)}}
        % else:
            % assert False
        % end
    % end
% end
    return offset - offset0
#@ endblock

#@ block: struct_unpack_merge (flds, klass)
% fmt, size, form1, form2 = c_py_get_merge_unpack_info(flds)
{{form1}} = {{klass}}._packer_{{fmt}}.unpack_from(buf, offset)
% if form2:
{{form2}}
% end
offset += {{size}}
#@ endblock

#@ block: struct_unpack_string (*EntryDef)
self.{{name}}, size = tdr_unpack_string(buf, offset, '{{structdef.name}}.{{name}}')
offset += size
#@ endblock

#@ block: struct_unpack_struct (*EntryDef)
offset += self.{{name}}.unpack(buf, offset, cutver)
#@ endblock

#@ block: struct_unpack_array (*EntryDef)
% typeid = typedef.typeid
% if refer:
c = self.{{refer}}
% else:
c = {{count}}
% end
% if typeid in PY_PACKINFO_PRIMARY_TYPE:
    % fmt = PY_PACKINFO_PRIMARY_TYPE[typeid]
    % size = FIXSIZE_TYPES[typeid]
self.{{name}} = list(struct.unpack_from('!%d{{fmt}}' % c, buf, offset))
offset += c * {{size}}
% elif typeid in PY_PACKINFO_DATETIME:
    % fmt, _, expr = PY_PACKINFO_DATETIME[typeid]
    % size = FIXSIZE_TYPES[typeid]
tmp_{{name}} = struct.unpack_from('!%d{{fmt}}' % c, buf, offset)
offset += {{size}} * c
self.{{name}} = [c_render_code(expr, var='x') for x in tmp_{{name}}]
% elif typeid == TYPE_STRING:
{{c_render_block('struct_unpack_array_string', 0, _context_)}}
% elif typeid == TYPE_IP:
{{c_render_block('struct_unpack_array_ip', 0, _context_)}}
% elif typeid in (TYPE_STRUCT, TYPE_UNION):
{{c_render_block('struct_unpack_array_struct', 0, _context_)}}
% else:
    % assert False
% end
#@ endblock

#@ block: struct_unpack_array_string (*EntryDef)
vals = []
for i in xrange(c):
    val, size = tdr_unpack_string(buf, offset, '{{structdef.name}}.{{name}}[%d]' % i)
    offset += size
    vals.append(val)
self.{{name}} = vals
#@ endblock

#@ block: struct_unpack_array_ip (*EntryDef)
% fmt, vexpr = PY_PACKINFO_IP[typeid]
% size = FIXSIZE_TYPES[typeid]
vals = []
for i in xrange(c):
    ip, = tdr_packer_{{fmt}}.unpack_from(buf, offset)
    offset += {{size}}
    vals.append({{c_render_code(vexpr, 0, var='ip')}})
self.{{name}} = vals
#@ endblock

#@ block: struct_unpack_array_struct (*EntryDef)
vals = []
for i in xrange(c):
    % if typeid == TYPE_STRUCT:
    v = {{type}}()
    % elif typeid == TYPE_UNION:
    v = {{type}}(self.{{select}})
    % else:
        assert False
    % end
    size = v.unpack(buf, offset, cutver)
    offset += size
    vals.append(v)
self.{{name}} = vals
#@ endblock

#@ block: struct_make_packer (*StructDef)
% fmts = []
% for gtype, ver, flds in c_grouping_pack_flds(fields):
    % if gtype == PY_PACK_GROUP_MERGE:
        % fmt = c_py_get_merge_pack_info(flds)[0]
        % fmts.append(fmt)
    % end
% end
% fix_packer_fmt = set(PY_PACKINFO_PRIMARY_TYPE.values() \
                       + [v[0] for v in PY_PACKINFO_IP.values()] \
                       + [v[0] for v in PY_PACKINFO_DATETIME.values()])
% fmts = list(set(fmts))
% fmts.sort()
% for fmt in fmts:
    % if fmt in fix_packer_fmt:
_packer_{{fmt}} = tdr_packer_{{fmt}}
    % else:
_packer_{{fmt}} = struct.Struct('!{{fmt}}')
    % end
% end
#@ endblock

#@ block: struct_pack_into_dict (*StructDef)
def pack_into_dict(self):
{{c_render_block('struct_pack_check_array', 4, _context_)}}
    data = {}
% for fld in fields:
    % if fld.typeid in PY_PACKINFO_PRIMARY_TYPE or fld.typeid == TYPE_STRING:
    data['{{fld.name}}'] = self.{{fld.name}}
    % elif fld.count:
    data['{{fld.name}}'] = [{{c_render_block('field_tojson', fld=fld, vname='item')}} for item in self.{{fld.name}}]
    % else:
    data['{{fld.name}}'] = {{c_render_block('field_tojson', fld=fld, vname='self.'+fld.name)}}
    % end
% end
    return data
#@ endblock

#@ block: struct_unpack_from_dict (*StructDef)
def unpack_from_dict(self, kvs):
% for fld in fields:
    if '{{fld.name}}' in kvs:
    % if fld.count:
        v = kvs['{{fld.name}}']
        if len(v) > {{fld.count}}:
            raise TdrException('too-large-array:{{fld.structdef.name}}.{{fld.name}}')
        self.{{fld.name}} = [{{c_render_block('field_fromjson', fld=fld, vname='item')}} for item in v]
        % if fld.refer:
        self.{{fld.refer}} = len(self.{{fld.name}}) # refer
        % end
    % elif fld.typeid in (TYPE_STRUCT, TYPE_UNION):
        self.{{fld.name}}.unpack_from_dict(kvs['{{fld.name}}'])
    % else:
        self.{{fld.name}} = {{c_render_block('field_fromjson', fld=fld, vname="kvs['%s']" % fld.name)}}
    % end
% end
    return self
#@ endblock


#@ block: field_tojson (fld, vname)
% if fld.typeid == TYPE_TIME:
{{vname}}.strftime('%H:%M:%S') if {{vname}} else ''\\
% elif fld.typeid == TYPE_DATE:
{{vname}}.strftime('%Y-%m-%d') if {{vname}} else ''\\
% elif fld.typeid == TYPE_DATETIME:
{{vname}}.strftime('%Y-%m-%d %H:%M:%S') if {{vname}} else ''\\
% elif fld.typeid == TYPE_IP:
socket.inet_ntoa({{vname}})\\
% elif fld.typeid in (TYPE_STRUCT, TYPE_UNION):
{{vname}}.pack_into_dict()\\
% else:
    % assert False
% end
#@ endblock

#@ block: field_fromjson (fld, vname)
% if fld.typeid in (TYPE_INT8, TYPE_UINT8, TYPE_INT16, TYPE_UINT16,\
                    TYPE_INT32, TYPE_UINT32, TYPE_INT64, TYPE_UINT64):
int({{vname}})\\
% elif fld.typeid in (TYPE_FLOAT, TYPE_DOUBLE):
float({{vname}})\\
% elif fld.typeid == TYPE_STRING:
{{vname}}\\
% elif fld.typeid == TYPE_CHAR:
{{vname}}[:1]\\
% elif fld.typeid == TYPE_TIME:
tdr_str2time({{vname}})\\
% elif fld.typeid == TYPE_DATE:
tdr_str2date({{vname}})\\
% elif fld.typeid == TYPE_DATETIME:
tdr_str2datetime({{vname}})\\
% elif fld.typeid == TYPE_IP:
socket.inet_aton({{vname}})\\
% elif fld.typeid == TYPE_STRUCT:
{{fld.type}}().unpack_from_dict({{vname}})\\
% elif fld.typeid == TYPE_UNION:
{{fld.type}}(self.{{fld.select}}).unpack_from_dict({{vname}})\\
% else:
    % assert False
% end
#@ endblock


# for union

#@ block: union_selector
SELECTORS = {
% for fld in fields:
    % if fld.typeid == TYPE_STRUCT:
    {{fld.id}}:('{{fld.name}}', {{fld.typeid}}, {{fld.type}}, {{fld.maxsize}}),
    % else:
    {{fld.id}}:('{{fld.name}}', {{fld.typeid}}, None, {{fld.maxsize}}),
    % end
% end
}
#@ endblock

#@ block: union_init
def __init__(self, selector):
    self.__id = selector
    if selector not in {{name}}.SELECTORS:
        # 与 tdr 处理方式保持一直，非法selector 跳过
        return
    fname, typeid, ftype = {{name}}.SELECTORS[selector][:3]
    if typeid == {{TYPE_STRUCT}}:
        setattr(self, fname, ftype())
% other_flds = filter(lambda f:f.typeid != TYPE_STRUCT, fields)
% for fld in other_flds:
    if selector == {{fld.id}}:
{{c_render_block('init_field', 8, fld)}}
        return
% end

def __get_select_info(self):
    select_info = {{name}}.SELECTORS.get(self.__id)
    if not select_info:
        return (None, None, None)
    return select_info[:3]
#@ endblock

#@ block: union_tostr
def tostr(self, out, indent = 0):
    fname, ftypeid, _ = self.__get_select_info()
    if not fname:
        return '<wrong select id:%s>' % self.__id
    spc = ' ' * indent
    out.write('{{name}}=[\n%s  %s:' % (spc, fname))
    if ftypeid == {{TYPE_STRUCT}}:
        getattr(self, fname).tostr(out, indent + 2)
    else:
        out.write(str(getattr(self, fname)))
        out.write('\n')
    out.write(spc + ']')
#@ endblock

#@ block: union_pack (*UnionDef)
def pack(self, cutver = 0, maxsize = 0):
    if maxsize == 0:
        maxsize = {{maxsize}}

    buf = bytearray(maxsize)
    n = self.pack_into(buf, 0, cutver)
    return buf[:n]

def pack_into(self, buf, offset = 0, cutver = 0):
    fname, ftypeid, _ = self.__get_select_info()
    if not fname:
        return 0
    if ftypeid == {{TYPE_STRUCT}}:
        return getattr(self, fname).pack_into(buf, offset, cutver)
% other_flds = filter(lambda f:f.typeid != TYPE_STRUCT, fields)
% if other_flds:
    if cutver == 0:
        cutver == self.CURRVERSION
% end
% for fld in other_flds:
    if self.__id == {{fld.id}}:
        if cutver < {{fld.version}}:
            return 0
        offset0 = offset
    % if fld.count:
{{c_render_block('struct_pack_array', 8, fld)}}
    % elif fld.typeid == TYPE_STRING:
{{c_render_block('struct_pack_string', 8, fld)}}
    % else:
{{c_render_block('struct_pack_merge', 8, flds=[fld], klass=name)}}
    % end
        return offset - offset0
% end
#@ endblock

#@ block: union_unpack (*UnionDef)
def unpack(self, buf, offset = 0, cutver = 0):
    fname, ftypeid, _ = self.__get_select_info()
    if not fname:
        return 0
    if ftypeid == {{TYPE_STRUCT}}:
        return getattr(self, fname).unpack(buf, offset, cutver)
% other_flds = filter(lambda f:f.typeid != TYPE_STRUCT, fields)
% if other_flds:
    if cutver == 0:
        cutver == self.CURRVERSION
% end
% for fld in other_flds:
    if self.__id == {{fld.id}}:
        if cutver < {{fld.version}}:
            return 0
        offset0 = offset
    % if fld.count:
{{c_render_block('struct_unpack_array', 8, fld)}}
    % elif fld.typeid == TYPE_STRING:
{{c_render_block('struct_unpack_string', 8, fld)}}
    % else:
{{c_render_block('struct_unpack_merge', 8, flds=[fld], klass=name)}}
    % end
        return offset - offset0
% end
#@ endblock

#@ block: union_make_packer (*UnionDef)
% fmts = []
% for f in fields:
    % if f.typeid in PY_PACKINFO_PRIMARY_TYPE:
        % fmts.append(PY_PACKINFO_PRIMARY_TYPE[f.typeid])
    % elif f.typeid in PY_PACKINFO_DATETIME:
        % fmts.append(PY_PACKINFO_DATETIME[f.typeid][0])
    % end
% end
% fmts = list(set(fmts))
% fmts.sort()
% for fmt in fmts:
_packer_{{fmt}} = tdr_packer_{{fmt}}
% end
#@ endblock

#@ block: union_pack_into_dict (*UnionDef)
def pack_into_dict(self):
% json_types = PY_PACKINFO_PRIMARY_TYPE.keys() + [TYPE_STRING]
    fname, ftypeid, _ = self.__get_select_info()
    if not fname:
        return
    v = getattr(self, fname)
    # TODO: array should be more safe
    if isinstance(v, list):
        return {fname:[tdr_to_json(ftypeid, x) for x in v]}
    else:
        return {fname:tdr_to_json(ftypeid, v)}
#@ endblock

#@ block: union_unpack_from_dict (*UnionDef)
def unpack_from_dict(self, kvs):
    fname, ftypeid, klass = self.__get_select_info()
    if not fname or fname not in kvs:
        return self
    v = kvs[fname]
    # TODO: array should be more safe
    if isinstance(v, list):
        setattr(self, fname, [tdr_from_json(ftypeid, v, klass)])
    else:
        setattr(self, fname, tdr_from_json(ftypeid, v, klass))
    return self
#@ endblock

#@ block: struct_code

{{c_render_block('class_head', 0, _context_)}}
{{c_render_block('struct_init', 4, _context_)}}
{{c_render_block('union_wrapper', 4, _context_)}}
{{c_render_block('class_str', 4, _context_)}}
{{c_render_block('struct_tostr', 4, _context_)}}
{{c_render_block('struct_pack', 4, _context_)}}
{{c_render_block('struct_unpack', 4, _context_)}}
{{c_render_block('struct_make_packer', 4, _context_)}}
{{c_render_block('struct_pack_into_dict', 4, _context_)}}
{{c_render_block('struct_unpack_from_dict', 4, _context_)}}
#@ endblock

#@ block: union_code

{{c_render_block('class_head', 0, _context_)}}
{{c_render_block('union_selector', 4, _context_)}}
{{c_render_block('union_init', 4, _context_)}}
{{c_render_block('union_tostr', 4, _context_)}}
{{c_render_block('class_str', 4, _context_)}}
{{c_render_block('union_pack', 4, _context_)}}
{{c_render_block('union_unpack', 4, _context_)}}
{{c_render_block('union_make_packer', 4, _context_)}}
{{c_render_block('union_pack_into_dict', 4, _context_)}}
{{c_render_block('union_unpack_from_dict', 4, _context_)}}
#@ endblock

#@ block: macro
% if desc:
# {{desc}}
% end
{{name}} = {{value}}
#@ endblock

#@ block: macros_group
# {{name}}
#@ endblock

#@ block: import_lib
from {{modname}} import *
#@ endblock

#@ block: python_file
{{c_render_block('file_head', 0, _context_)}}
{{c_render_block('common_code', 0, _context_)}}
#@ endblock
